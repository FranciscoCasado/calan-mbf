# Calan Multi-BeamFormer

The Calan-MBF project aims to build a platform for multiple-beamforming applications, based on [CASPER](https://www.google.com) hardware.

## Requirements & Libraries
The core software for development is Matlab 2013a and  Xilinx ISE 14.7, running in a Ubuntu 12.04 machine (newer versions are also apt, but this is the OS we use at the lab).

Some other softwares needed are Ruby 1.9.1 (*with RubyGems*) and Python 2.7.

Important libraries can be obtained/installed as follows:
1. CASPER `mlib_devel`:
Open a terminal and execute these commands
  ```bash
  git clone https://github.com/FranciscoCasado/mlib_devel.git
  ```
  This repo is a fork from [casper-astro](https://github.com/casper-astro/mlib_devel) (0c3f334) with downgraded pcores in order to compile and *work* with test files (detailed later).

2. Missing `pcores`:
As as the CASPER [toolflow settings page](https://casper.berkeley.edu/wiki/MSSGE_Setup_with_Xilinx_14.x_and_Matlab_2012b) says, there are some *tweaks to be able to compile*. The most important is to download the compressed folder that has the missing `pcores` from Xilinx. Extract the files to `mlib_devel/xps_base/XPS_ROACH2_base/pcores`.

3. Set local environment variables:
In the `mlib_devel` folder, there is the file `startsg`, which can be run from a terminal and opens matlab and loads the necessary CASPER libraries. This file requieres de definition of at least three environment variables that can be written into another file (created by each user) named `startsg.local`:
  ```
  MATLAB_PATH=/usr/local/MATLAB/R2013a/
  XILINX_PLATFORM=lin64
  XILINX_PATH=/opt/Xilinx/14.7/ISE_DS
  ```
 Replace the correct Matlab and Xilinx version numbers in each path. Also verify that these are the actual installation felder paths.

4. CASPER `corr` library: install it via pip
  ```bash
  pip install corr
  ```
  This python library includes `katcp`, which is required to stablish communication between your PC and a ROACH2.

5. Ruby files for testing - *by [davidm](https://github.com/david-macmahon)*

  ```bash
  gem install --source http://astro.berkeley.edu/~davidm/gems adc16
  git clone git://github.com/david-macmahon/casper_adc16.git
  gem install pgplot
  gem install --source http://astro.berkeley.edu/~davidm/gems pgplotter
  gem install gsl
  ```
If `gsl` installation fails, [this page](https://coderwall.com/p/jk--aw/ruby-gsl-error-failed-to-build-gem-native-extension) should help.

## Hardware
A [ROACH2 rev2](https://casper.berkeley.edu/wiki/ROACH2) and an [ADC16x250-8 coax rev 2](https://casper.berkeley.edu/wiki/ADC16x250-8_coax_rev_2) (single ended SMB input). The clock is generated by a Valon Synthesizer 5007, at a frequency of 200 MHz.

This project also considers four down-conversion boards from 5 GHz to <20 MHz, based on the MAX2851 chip. More info on these boards can be found in the folder `utils/down_converters`.

### Test the ADC16

The `utils` folder contains the source written by davidm (in Ruby). Every model that includes an _adc16_ yellow block is useful for testing the board.

1. Power up the ROACH2 and connect it to the local network (same as your PC). Connect the clock source to the ADC16 board (at the lab we have a Valon Synthesizer) and plug the ADC16 inputs to some RF signal. Make sure the clock source supplies 6 dBm (valon_synth lvl. 4) and the RF signal of each input is near 0 dBm.
2. On your PC, open an iPython session to upload the .bof file to the ROACH2 with katcp. In a terminal, type `$ ipython` and enter the following commands:
  ```python
  In [1]: import corr
  In [2]: fpga = corr.katcp_wrapper.FpgaClient('ROACH2_ip_address')
  In [3]: fpga.upload_bof('utilities/adc16_test/model/<bof_file.bof>', 60000)
  ```
  The number 60000 in the third line corresponds to the port that the file transfer will use, as the default katcp 7147 is already in use. Any number greater than 10000 should also work.
  To check that the bof_file arrived, type
  ```python
  In [4]: fpga.listbof()
  ```
3. Open another terminal and execute the following scripts
  ```bash
  ./adc16_init <bof_file.bof>
  ./adc16_check
  ```
  The first line programs the model into the ROACH2. The later reads data directly from the _adc16_ board and plots 16 signals, one from each channel. In normal operation, feeding a pure sine wave below 20 MHz to every channel should look "good" in each plot.
. This script runs two ruby routines that turn ADC boards on, calibrates all channels (A,B,C,D) and then plots a snapshot of every signal. These routines can be run individually from the terminal:
  ```bash
  cd utils/adc16_test/src/bin
  ruby1.9.1 ./adc16_init.rb --demux 1 ROACH2_ip_address adc16_1brd_200_rev2a.bof
  ruby1.9.1 ./adc16_plot_chans.rb ROACH2_ip_address
  ```
  Note that the .bof file name does not contain the path, as it is the copy uploaded to the ROACH2.

### Calibration 

Current state of the project is calibrating amplitude and phase for each channel. Coarse amplitude calibration is achieved by setting the vga_gain of the down-converter chips. Fine amplitude calibration and phase calibration are to be managed by the ROACH2.

### Amplitude Calibration

The down-converters (MAX2851) have programmable analog gain adjustment. In order to monitor the amplitude while changing the gain, a simple model and python scripts are available in the `models/read_power` folder. The model consists of snapshots and power integrators; the python script is permanently reading the data and displaying them in two figures: _RMS_-power and snapshots of everys ignal.

To run this script, the user must have programmed the ROACH2 and calibrated the ADC board. After that, the python script can be run:
  ```bash
  ./adc16_init read_power_16chan.bof
  python read_power_16chan.py
  ```
This script plots the power in arbitrary units (dB) of every channel and also shows a snapshot of every channel. This information allows the user to compare all averaged powers and the state of each signal.

### Phase Calibration

_Currently under development_

The FFT of each channel must be computed by exploiting the result of a complex spectrum.
